--[[
Ordered table iterator
From http://lua-users.org/wiki/SortedIteration
]]

function __genOrderedIndex( t )
    local orderedIndex = {}
    for key in pairs(t) do
        table.insert( orderedIndex, key )
    end
    table.sort( orderedIndex )
    return orderedIndex
end

function orderedNext(t, state)
    -- Equivalent of the next function, but returns the keys in the alphabetic
    -- order. We use a temporary ordered key table that is stored in the
    -- table being iterated.

    local key = nil
    --print("orderedNext: state = "..tostring(state) )
    if state == nil then
        -- the first time, generate the index
        t.__orderedIndex = __genOrderedIndex( t )
        key = t.__orderedIndex[1]
    else
        -- fetch the next value
        for i = 1,table.getn(t.__orderedIndex) do
            if t.__orderedIndex[i] == state then
                key = t.__orderedIndex[i+1]
            end
        end
    end

    if key then
        return key, t[key]
    end

    -- no more value to return, cleanup
    t.__orderedIndex = nil
    return
end

function orderedPairs(t)
    -- Equivalent of the pairs() function on tables. Allows to iterate
    -- in order
    return orderedNext, t, nil
end

-- Writes a single recipe to a table in the output file
local write_recipe = function(file, recipe)
	file:write("\t{\n")
	for key, val in orderedPairs(recipe) do
		file:write("\t\t"..key.." = ")
		if key == "output" then
			file:write("\t\"" .. ItemStack(val):to_string() .."\",\n")
		elseif type(val) == "table" then
			file:write("\t{")
			for kk, vv in orderedPairs(val) do
				if type(vv) == "string" then
					file:write("[\"" .. kk .. "\"] = \"" .. tostring(vv) .. "\", ")
				else
					file:write("[\"" .. kk .. "\"] = " .. tostring(vv) .. ", ")
				end
			end
			file:write("},\n")
		elseif type(val) == "string" then
			file:write("\t\"" .. tostring(val) .. "\",\n")
		else
			file:write("\t" .. tostring(val) .. ",\n")
		end			
	end
	file:write("\t},\n")
end

-- Dumps all recipes from the existing crafting system into a file that can be used to recreate them.
local save_recipes = function(param)
	local path = minetest.get_worldpath()
	local filename = path .. "/" .. param .. ".lua"
	local file, err = io.open(filename, "w")
	if err ~= nil then
		minetest.log("error", "[simplecrafting_lib] Could not save recipes to \"" .. filename .. "\"")
		return false
	end
	
	file:write("return {\n")
	for craft_type, recipe_list in orderedPairs(simplecrafting_lib.type) do	
		file:write("-- Craft Type " .. craft_type .. "--------------------------------------------------------\n[\"" .. craft_type .. "\"] = {\n")
		for out, recipe_list in orderedPairs(recipe_list.recipes_by_out) do
			file:write("-- Output: " .. out .. "\n")
			for _, recipe in ipairs(recipe_list) do
				write_recipe(file, recipe)
			end
		end
		file:write("},\n")
	end
	file:write("}\n")

	file:flush()
	file:close()
	return true
end

-- registers all recipes in the provided filename, which is usually a file generated by save_recipes and then perhaps modified by the developer.
local load_recipes = function(param)
	local path = minetest.get_worldpath()
	local filename = path .. "/" .. param .. ".lua"
	local new_recipes = loadfile(filename)
	if new_recipes == nil then
		minetest.log("error", "[simplecrafting_lib] Could not read recipes from \"" .. filename .. "\"")
		return false
	end
	new_recipes = new_recipes()	
	
	for crafting_type, recipes in pairs(new_recipes) do
		for _, recipe in pairs(recipes) do
			simplecrafting_lib.register(crafting_type, recipe)
		end	
	end	
	return true
end

-- What the function name says it does
local get_recipes_that_are_in_first_recipe_list_but_not_in_second_recipe_list = function(first_recipe_list, second_recipe_list)
	if first_recipe_list == nil then
		return nil
	elseif second_recipe_list == nil then
		return first_recipe_list
	end
	
	local returns

	for _, first_recipe in pairs(first_recipe_list) do
		local found = false
		for _, second_recipe in pairs(second_recipe_list) do
			if simplecrafting_lib.recipe_equals(first_recipe, second_recipe) then
				found = true
				break
			end
		end
		if found ~= true then
			returns = returns or {}
			table.insert(returns, first_recipe)
		end
	end
	
	return returns
end

-- Used in diff_recipes for writing lists of recipes
local write_recipe_lists = function(file, recipe_lists)
	for craft_type, recipe_list in orderedPairs(recipe_lists) do	
		file:write("-- Craft Type " .. craft_type .. "--------------------------------------------------------\n[\"" .. craft_type .. "\"] = {\n")
		for _, recipe in ipairs(recipe_list) do
			write_recipe(file, recipe)
		end
		file:write("},\n")
	end
end

-- compares the recipes in the infile (of the form written by save_recipes) to the recipes in the existing crafting system, and outputs differences to outfile
local diff_recipes = function(infile, outfile)
	local path = minetest.get_worldpath()
	local filename = path .. "/" .. infile .. ".lua"
	local new_recipes = loadfile(filename)
	if new_recipes == nil then
		minetest.log("error", "[simplecrafting_lib] Could not read recipes from \"" .. filename .. "\"")
		return false
	end
	new_recipes = new_recipes()
	
	local new_only_recipes = {}
	local existing_only_recipes = {}
	
	for craft_type, recipe_lists in pairs(simplecrafting_lib.type) do
		if new_recipes[craft_type] ~= nil then
			new_only_recipes[craft_type] = get_recipes_that_are_in_first_recipe_list_but_not_in_second_recipe_list(new_recipes[craft_type], recipe_lists.recipes)
		else
			existing_only_recipes[craft_type] = recipe_lists.recipes
		end
	end
	for craft_type, recipe_lists in pairs(new_recipes) do
		local existing_recipes = simplecrafting_lib.type[craft_type]
		if existing_recipes ~= nil then
			existing_only_recipes[craft_type] = get_recipes_that_are_in_first_recipe_list_but_not_in_second_recipe_list(existing_recipes.recipes, recipe_lists)
		else
			new_only_recipes[craft_type] = recipe_lists
		end
	end
	
	filename = path .. "/" .. outfile .. ".txt"
	local file, err = io.open(filename, "w")
	if err ~= nil then
		minetest.log("error", "[simplecrafting_lib] Could not save recipe diffs to \"" .. filename .. "\"")
		return false
	end
		
	file:write("-- Recipes found only in the external file:\n--------------------------------------------------------\n")
	write_recipe_lists(file, new_only_recipes)
	file:write("\n")

	file:write("-- Recipes found only in the existing crafting database:\n--------------------------------------------------------\n")
	write_recipe_lists(file, existing_only_recipes)
	file:write("\n")
	
	file:flush()
	file:close()
	
	return true
end

minetest.register_chatcommand("saverecipes", {
	params = "<file>",
	description = "Save the current recipes to \"(world folder)/<file>.lua\"",
	func = function(name, param)
		if not minetest.check_player_privs(name, {server = true}) then
			minetest.chat_send_player(name, "You need the \"server\" priviledge to use this command.", false)
		end
		
		if param == "" then
			minetest.chat_send_player(name, "Invalid usage, filename parameter needed", false)
			return
		end
		
		if save_recipes(param) then
			minetest.chat_send_player(name, "Recipes saved", false)
		else
			minetest.chat_send_player(name, "Failed to save recipes", false)
		end
	end,
})

minetest.register_chatcommand("clearrecipes", {
	params = "",
	description = "Clear all recipes from simplecrafting_lib",
	func = function(name, param)
		if not minetest.check_player_privs(name, {server = true}) then
			minetest.chat_send_player(name, "You need the \"server\" priviledge to use this command.", false)
		end
		simplecrafting_lib.type = {}
		minetest.chat_send_player(name, "Recipes cleared", false)
	end,
})

minetest.register_chatcommand("loadrecipes", {
	params="<file>",
	description="Clear recipes and load replacements from \"(world folder)/<file>.lua\"",
	func = function(name, param)
		if not minetest.check_player_privs(name, {server = true}) then
			minetest.chat_send_player(name, "You need the \"server\" priviledge to use this command.", false)
		end

		if param == "" then
			minetest.chat_send_player(name, "Invalid usage, filename parameter needed", false)
			return
		end
		
		if load_recipes(param) then		
			minetest.chat_send_player(name, "Recipes loaded", false)
		else
			minetest.chat_send_player(name, "Failed to load recipes", false)
		end
	end,
})

function split(inputstr, seperator)
	if seperator == nil then
		seperator = "%s"
	end
	local out={}
	local i=1
	for substring in string.gmatch(inputstr, "([^"..seperator.."]+)") do
		out[i] = substring
		i = i + 1
	end
	return out
end

minetest.register_chatcommand("diffrecipes", {
	params="<infile> <outfile>",
	description="Compares existing recipe data to the data in \"(world folder)/<infile>.lua\", outputting the differences to \"(world folder)/<outfile>.txt\"",
	func = function(name, param)
		if not minetest.check_player_privs(name, {server = true}) then
			minetest.chat_send_player(name, "You need the \"server\" priviledge to use this command.", false)
		end

		local params = split(param)
		if #params ~= 2 then
			minetest.chat_send_player(name, "Invalid usage, two filename parameters separted by a space are needed", false)
			return
		end
		
		if diff_recipes(params[1], params[2]) then
			minetest.chat_send_player(name, "Recipes diffed", false)
		else
			minetest.chat_send_player(name, "Failed to diff recipes", false)
		end
	end,
})